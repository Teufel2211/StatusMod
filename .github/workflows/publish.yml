name: Build and publish (build -> publish)

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      artifact_version: ${{ steps.build_select_jar.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: Make gradlew executable
        run: chmod +x ./gradlew

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Build (and write version file)
        run: ./gradlew clean build writeVersion --no-daemon -Dorg.gradle.java.home="$JAVA_HOME"

      - name: Select runtime JAR and read version
        id: build_select_jar
        run: |
          set -euo pipefail
          # choose the first non-sources jar
          JAR=$(ls build/libs/*.jar | grep -v '\-sources\.jar' | head -n1)
          if [ -z "$JAR" ]; then
            echo "No runtime JAR found in build/libs" >&2
            exit 1
          fi
          echo "Found runtime jar: $JAR"
          # read the version written by the Gradle task
          if [ -f build/version.txt ]; then
            VERSION=$(cat build/version.txt | tr -d '\n')
          else
            # fallback: infer from jar filename
            BASENAME=$(basename "$JAR")
            NAME="${BASENAME%.*}"
            VERSION="${NAME##*-}"
          fi
          echo "Detected version: $VERSION"
          echo "jar=$JAR" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: statusmod-jar
          path: ${{ steps.build_select_jar.outputs.jar }}

  publish:
    needs: build
    # Run publish for branch pushes initiated by humans, or for tag pushes (allow bot-created tags)
    if: >
      github.event_name == 'push' && (
        (startsWith(github.ref, 'refs/heads/') && github.actor != 'github-actions[bot]') ||
        startsWith(github.ref, 'refs/tags/')
      )
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: statusmod-jar
          path: build/libs

      - name: Select runtime JAR
        id: select_jar
        run: |
          set -euo pipefail
          # choose the first non-sources jar
          JAR=$(ls build/libs/*.jar | grep -v '\-sources\.jar' | head -n1)
          if [ -z "$JAR" ]; then
            echo "No runtime JAR found in build/libs" >&2
            exit 1
          fi
          echo "Found runtime jar: $JAR"
          echo "jar=$JAR" >> "$GITHUB_OUTPUT"

      - id: create_tag
        name: Create and push tag for this version
        if: always()
        env:
          PUBLISH_PAT: ${{ secrets.PUBLISH_PAT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ARTIFACT_VERSION: ${{ needs.build.outputs.artifact_version }}
        run: |
          set -euo pipefail
          if [ -n "$ARTIFACT_VERSION" ]; then
            TAG="v$ARTIFACT_VERSION"
          else
            TAG="v$(cat version.txt)"
          fi
          echo "Creating tag $TAG"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          # if the tag already exists, skip creating/pushing it
          # if the workflow was triggered by a tag push, use that tag directly
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            echo "Triggered by tag $TAG"
            echo "tag=$TAG" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if git ls-remote --tags origin | grep -q "refs/tags/$TAG$"; then
            echo "Tag $TAG already exists on remote â€” skipping"
          else
            git tag "$TAG"
            # prefer PUBLISH_PAT (personal access token) if provided, fallback to GITHUB_TOKEN
            if [ -n "$PUBLISH_PAT" ]; then
              TOKEN="$PUBLISH_PAT"
              echo "Using PUBLISH_PAT to push tag"
            else
              TOKEN="$GITHUB_TOKEN"
              echo "Using GITHUB_TOKEN to push tag"
            fi
            git push "https://x-access-token:$TOKEN@github.com/${{ github.repository }}.git" "$TAG"
          fi
          # export the tag to GITHUB_OUTPUT so later steps can reference it
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.create_tag.outputs.tag }}
          name: StatusMod ${{ steps.create_tag.outputs.tag }}
          files: ${{ steps.select_jar.outputs.jar }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload to Modrinth & CurseForge (mc-publish)
        uses: Kir-Antipov/mc-publish@v3.3
        with:
          version-type: release
          modrinth-id: ${{ secrets.MODRINTH_PROJECT_ID }}
          modrinth-token: ${{ secrets.MODRINTH_TOKEN }}
          curseforge-id: ${{ secrets.CURSEFORGE_PROJECT_ID }}
          curseforge-token: ${{ secrets.CURSEFORGE_TOKEN }}
          files: ${{ steps.select_jar.outputs.jar }}
          game-versions: 1.21.10
          loaders: fabric

      - name: Upload via fallback script (direct API)
        if: always()
        env:
          MODRINTH_TOKEN: ${{ secrets.MODRINTH_TOKEN }}
          MODRINTH_PROJECT_ID: ${{ secrets.MODRINTH_PROJECT_ID }}
          CURSEFORGE_API_KEY: ${{ secrets.CURSEFORGE_TOKEN }}
          CURSEFORGE_PROJECT_ID: ${{ secrets.CURSEFORGE_PROJECT_ID }}
          CURSEFORGE_JAVA_VERSION: ${{ secrets.CURSEFORGE_JAVA_VERSION }}
          CURSEFORGE_ENVIRONMENT: ${{ secrets.CURSEFORGE_ENVIRONMENT }}
          VERSION: ${{ steps.create_tag.outputs.tag }}
        run: |
          set -euo pipefail
          # allow optional secret overrides; provide sensible defaults
          CF_JAVA="${CURSEFORGE_JAVA_VERSION:-21}"
          CF_ENV="${CURSEFORGE_ENVIRONMENT:-client}"
          echo "Using CurseForge Java version: $CF_JAVA, environment: $CF_ENV"
          export CURSEFORGE_JAVA_VERSION="$CF_JAVA"
          export CURSEFORGE_ENVIRONMENT="$CF_ENV"
          python ./.github/scripts/upload_release.py "${{ steps.select_jar.outputs.jar }}"
